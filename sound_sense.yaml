# SoundSense for Home Assistant Voice
# 
# This package adds sound sensing smart capabilities
# to Home Assistant Voice devices.

globals:
  - id: dynamic_volume_enabled
    type: bool
    restore_value: yes
    initial_value: 'false'
  - id: last_dynamic_volume_calculation
    type: float
    restore_value: no
    initial_value: '0'
  # Sound sensing globals - updated by microphone trigger
  - id: current_sound_level
    type: float
    restore_value: no
    initial_value: '0.0'

number:
  - platform: template
    name: "Dyn Minimum Volume"
    id: dynamic_min_volume
    min_value: 0
    max_value: 100
    step: 1
    initial_value: 15
    restore_value: true
    optimistic: true
    unit_of_measurement: "%"
    icon: "mdi:volume-medium"
    entity_category: config
    
  - platform: template 
    name: "Dyn Volume Level"
    id: dynamic_volume_level
    min_value: 0
    max_value: 10
    step: 1
    initial_value: 5
    restore_value: true
    optimistic: true
    icon: "mdi:volume-plus"    
    entity_category: config

  - platform: template 
    name: "Presence Threshold"
    id: presence_threshold
    min_value: 0
    max_value: 100
    step: 1
    initial_value: 30
    restore_value: true
    mode: box
    optimistic: true
    icon: "mdi:waveform"
    unit_of_measurement: "dB"
    entity_category: config

switch:
  - platform: template
    name: "Dynamic Volume"
    id: dynamic_volume_switch
    icon: "mdi:volume-vibrate"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    entity_category: config
    turn_on_action:
      - lambda: id(dynamic_volume_enabled) = true;
      - script.execute: update_dynamic_volume
    turn_off_action:
      - lambda: |-
          id(dynamic_volume_enabled) = false;
          // Reset to minimum volume when disabled
          id(external_media_player)
            ->make_call()
            .set_volume(id(dynamic_min_volume).state / 100.0f)
            .perform();

sensor:
  - platform: template
    name: "Ambient Sound Level"
    id: ambient_sound_level
    unit_of_measurement: "dB"
    accuracy_decimals: 1
    update_interval: 500ms
    icon: "mdi:microphone-outline"
    state_class: "measurement"
    filters:
      - sliding_window_moving_average:
          window_size: 3
          send_every: 2
      - throttle_average: 2s      
      - lambda: |-
          float current_level = id(current_sound_level);
          if (std::isnan(current_level)) return id(ambient_sound_level).state;
          
          static float last_valid = 0;
          static uint8_t reject_count = 0;
          
          if (current_level < (last_valid - 10) && last_valid > 0) {
            if (reject_count < 3) {
              reject_count++;
              return last_valid;
            }            
            reject_count = 0;
          } else {
            reject_count = 0;
          }
          last_valid = current_level;
          return current_level;
    lambda: |-
      return id(current_sound_level);

text_sensor: 
  - platform: template
    name: "Sound Detection"
    id: sound_detection_sensor
    icon: "mdi:waveform"
    update_interval: 2s
    lambda: |-
      float ambient_level = id(ambient_sound_level).state;             
      
      // Check for NaN
      if (std::isnan(ambient_level)) {
        return {"unknown"};
      }
            
      static uint32_t silence_start_time = 0;
      static uint8_t continuous_counter = 0;
      static float last_level = 0;
      static bool was_silent = true;
      static uint32_t noise_timestamp = 0;
      static std::string last_state = "";
      
      const uint8_t SILENCE_THRESHOLD = 5;
      const uint8_t NOISE_THRESHOLD = 18;
      const uint8_t CONTINUOUS_COUNT_TARGET = 8; // 8 counts * 2s update = 16s
      const uint16_t NOISE_TIMEOUT_MS = 10000;
      
      uint32_t current_time = millis();     

      // Save the last level for detecting sudden changes
      float temp_last_level = last_level;
      last_level = ambient_level;

      // Helper function to set state only if it has changed
      auto set_state = [](const std::string& new_state) -> optional<std::string> {
        if (new_state != last_state) {
          last_state = new_state;
          return new_state;
        }
        return {};
      };

      // Process sound states
      if (ambient_level < SILENCE_THRESHOLD) {
        // Silence or quieting state
        if (!was_silent) {
          silence_start_time = current_time;
          was_silent = true;
        }
        
        continuous_counter = 0;
        
        if (current_time - silence_start_time >= 15000) {
          return set_state("silence");
        } else {
          return set_state("quieting");
        }
      } else {
        // Non-silence states (active, noise, presence)
        was_silent = false;
        
        // Detect sudden noise spike and record timestamp
        if (temp_last_level < SILENCE_THRESHOLD && ambient_level >= NOISE_THRESHOLD) {
          noise_timestamp = current_time;
          return set_state("noise");
        }        
        
        if (ambient_level >= id(presence_threshold).state) {
          if (continuous_counter < 255)
            continuous_counter++;
          
          if (continuous_counter >= CONTINUOUS_COUNT_TARGET) {
            return set_state("presence");
          }
        } else {
          continuous_counter = 0;
        }    

        if (current_time - noise_timestamp <= NOISE_TIMEOUT_MS) {
          return set_state("noise");
        }        
        
        return set_state("active");
      }

script:
  # Script to process audio data from microphone trigger
  - id: process_audio_data
    parameters:
      audio_data: "std::vector<uint8_t>"
    then:
      - lambda: |-
          // Don't measure when media is playing to avoid feedback
          if (id(external_media_player)->state != media_player::MEDIA_PLAYER_STATE_IDLE) {
            return;
          }
          
          // Check if micro_wake_word is ready
          if (!id(mww).is_ready()) {
            return;
          }
          
          // Cast data to int16_t samples (assuming 32-bit samples, taking upper 16 bits)
          const int32_t* samples_32 = reinterpret_cast<const int32_t*>(audio_data.data());
          size_t sample_count = audio_data.size() / sizeof(int32_t);
          
          if (sample_count == 0) {
            return;
          }
          
          // Optimized loudness calculation - process every 4th sample for performance
          uint64_t sum_abs = 0;
          size_t processed_samples = 0;
          
          for (size_t i = 0; i < sample_count; i += 4) {
            // Take upper 16 bits and convert to absolute value
            int16_t sample_16 = (samples_32[i] >> 16) & 0xFFFF;
            sum_abs += abs(sample_16) >> 8;  // Shift right to prevent overflow
            processed_samples++;
          }
          
          if (processed_samples == 0) {
            return;
          }
          
          uint32_t avg_abs = sum_abs / processed_samples;
          
          // Using binary search for faster dB lookup
          static const uint8_t db_lookup[] = {
            0, 20, 32, 40, 46, 52, 56, 60, 64, 68, 72, 74, 76, 80, 82, 84,
            86, 88, 90, 92, 94, 96, 98, 100
          };      
          
          uint8_t low = 0;
          uint8_t high = sizeof(db_lookup) - 1;
          uint8_t index = high / 2;
          uint32_t threshold = 1 << index;
          
          while (low < high) {
            if (avg_abs > threshold) {
              low = index + 1;
            } else {
              high = index;
            }
            index = (low + high) / 2;
            threshold = 1 << index;
          }
          
          float db_value = index < sizeof(db_lookup) ? db_lookup[index] : db_lookup[sizeof(db_lookup) - 1];
          
          const float OFFSET = 15.0f;
          float db_adjusted = db_value + OFFSET;
          if (db_value == 0) db_adjusted = 0;
          
          // Store the calculated sound level in global variable
          id(current_sound_level) = db_adjusted;

  - id: update_dynamic_volume
    mode: single
    then:
      - lambda: |-
          if (!id(dynamic_volume_enabled)) return;
      
          // Don't update volume when media is playing
          if (id(external_media_player)->state != media_player::MEDIA_PLAYER_STATE_IDLE) return;
          
          float ambient_level = id(ambient_sound_level).state;
          if (std::isnan(ambient_level)) return;
          
          // Convert minimum volume percentage to 0-1 scale
          float min_volume = id(dynamic_min_volume).state / 100.0f;          
          float min_sound_db = 20.0f; // Minimum sound level in dB

          static uint8_t low_reading_count = 0;
          if (ambient_level <= 0) {
            low_reading_count++;
            
            if (low_reading_count >= 4 && abs(id(last_dynamic_volume_calculation) - min_volume) > 0.01f) {
              id(last_dynamic_volume_calculation) = min_volume;
              id(external_media_player)
                ->make_call()
                .set_volume(min_volume)
                .perform();              
            }
            return;
          } else {
            low_reading_count = 0;
          }

          float noise_response = id(dynamic_volume_level).state;
                              
          const int16_t NOISE_FLOOR_DB_FP = min_sound_db * 100;
          const int16_t MAX_DB_FP = 5000;         // 50.0dB * 100
          const int16_t DB_RANGE_FP = MAX_DB_FP - NOISE_FLOOR_DB_FP;
          
          // Convert ambient level to fixed-point
          int16_t ambient_level_fp = ambient_level * 100;
          
          // Calculate normalized level
          int16_t normalized_level_fp = 0;
          if (ambient_level_fp > NOISE_FLOOR_DB_FP) {
            normalized_level_fp = ((ambient_level_fp - NOISE_FLOOR_DB_FP) * 100) / DB_RANGE_FP;            
          }
          
          // Calculate boost
          int16_t boost_fp = (normalized_level_fp * (int)(noise_response * 25)) / 100;
          
          // Calculate new volume
          int16_t min_volume_fp = min_volume * 100;
          int16_t new_volume_fp = min_volume_fp + ((min_volume_fp * boost_fp) / 100);
          
          // Clamp to valid range and convert back to float
          new_volume_fp = std::min(new_volume_fp, (int16_t)100);
          float new_volume = new_volume_fp / 100.0f;
          
          // Add hysteresis to prevent rapid volume changes
          static float prev_volume = -1.0f;
          // Only update if changed more than threshold (1% change required)
          if (abs(new_volume - prev_volume) > 0.01f) {
            // Smoothing to avoid abrupt volume changes
            if (prev_volume >= 0) {              
              if (new_volume < prev_volume) {               
                new_volume = prev_volume * 0.9f + new_volume * 0.1f;
              } else {                
                new_volume = prev_volume * 0.7f + new_volume * 0.3f;
              }
            }
            
            prev_volume = new_volume;
            id(last_dynamic_volume_calculation) = new_volume;
            id(external_media_player)
              ->make_call()
              .set_volume(new_volume)
              .perform();
          }

interval:
  - interval: 5s
    then:
      - script.execute: update_dynamic_volume